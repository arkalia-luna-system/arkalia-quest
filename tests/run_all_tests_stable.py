#!/usr/bin/env python3
"""
üéÆ ARKALIA QUEST - LANCEUR DE TESTS VERSION STABLE
==================================================

Ce script lance TOUS les tests pour valider la version stable :
- Tests de fonctionnalit√©s compl√®tes
- Tests de performance et stress
- Tests de s√©curit√©
- Tests d'accessibilit√©
- Tests de base de donn√©es
- Tests PWA

Auteur: Assistant IA
Version: 1.0
"""

import json
import subprocess
import sys
import time
from datetime import datetime
from typing import Any


class StableVersionTestRunner:
    """Lanceur de tests pour la version stable"""

    def __init__(self):
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "tests": {},
            "summary": {},
            "recommendations": [],
        }

        # Liste des tests √† ex√©cuter
        self.test_modules = [
            {
                "name": "Version Stable Compl√®te",
                "file": "test_stable_version_complete.py",
                "description": "Tests complets de toutes les fonctionnalit√©s",
            },
            {
                "name": "Performance & Stress",
                "file": "test_performance_stress.py",
                "description": "Tests de performance et de charge",
            },
            {
                "name": "S√©curit√©",
                "file": "test_security_complete.py",
                "description": "Tests de s√©curit√© et vuln√©rabilit√©s",
            },
            {
                "name": "Gamification",
                "file": "test_gamification_complete.py",
                "description": "Tests du syst√®me de gamification",
            },
        ]

    def log(self, message: str, level: str = "INFO"):
        """Log avec timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] {level}: {message}")

    def check_server_status(self) -> bool:
        """V√©rifie que le serveur est d√©marr√©"""
        self.log("üîç V√©rification du serveur...")

        try:
            import requests

            response = requests.get("http://localhost:5001/", timeout=5)
            if response.status_code == 200:
                self.log("‚úÖ Serveur accessible", "SUCCESS")
                return True
            self.log(f"‚ùå Serveur r√©pond avec code {response.status_code}", "ERROR")
            return False
        except Exception as e:
            self.log(f"‚ùå Serveur inaccessible: {e}", "ERROR")
            return False

    def run_test_module(self, module: dict[str, str]) -> dict[str, Any]:
        """Ex√©cute un module de test"""
        self.log(f"üöÄ Lancement du test: {module['name']}")

        start_time = time.time()

        try:
            # Ex√©cuter le test
            result = subprocess.run(
                [sys.executable, f"tests/{module['file']}"],
                check=False,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minutes max par test
            )

            end_time = time.time()
            duration = end_time - start_time

            # Analyser le r√©sultat
            success = result.returncode == 0
            output = result.stdout
            error = result.stderr

            self.log(f"‚è±Ô∏è Dur√©e: {duration:.2f}s", "INFO")

            if success:
                self.log(f"‚úÖ {module['name']} - R√âUSSI", "SUCCESS")
            else:
                self.log(f"‚ùå {module['name']} - √âCHOU√â", "ERROR")
                if error:
                    self.log(f"Erreur: {error[:200]}...", "ERROR")

            return {
                "name": module["name"],
                "file": module["file"],
                "description": module["description"],
                "success": success,
                "duration": duration,
                "return_code": result.returncode,
                "output": output,
                "error": error,
            }

        except subprocess.TimeoutExpired:
            self.log(f"‚è∞ {module['name']} - TIMEOUT", "ERROR")
            return {
                "name": module["name"],
                "file": module["file"],
                "description": module["description"],
                "success": False,
                "duration": 300,
                "return_code": -1,
                "output": "",
                "error": "Timeout apr√®s 5 minutes",
            }
        except Exception as e:
            self.log(f"‚ùå Erreur ex√©cution {module['name']}: {e}", "ERROR")
            return {
                "name": module["name"],
                "file": module["file"],
                "description": module["description"],
                "success": False,
                "duration": 0,
                "return_code": -1,
                "output": "",
                "error": str(e),
            }

    def generate_summary(self) -> dict[str, Any]:
        """G√©n√®re un r√©sum√© des r√©sultats"""
        total_tests = len(self.test_modules)
        successful_tests = sum(
            1 for result in self.results["tests"].values() if result["success"]
        )
        failed_tests = total_tests - successful_tests

        success_rate = (successful_tests / total_tests * 100) if total_tests > 0 else 0

        total_duration = sum(
            result["duration"] for result in self.results["tests"].values()
        )

        return {
            "total_tests": total_tests,
            "successful_tests": successful_tests,
            "failed_tests": failed_tests,
            "success_rate": success_rate,
            "total_duration": total_duration,
            "timestamp": self.results["timestamp"],
        }

    def generate_recommendations(self) -> list[str]:
        """G√©n√®re des recommandations bas√©es sur les r√©sultats"""
        recommendations = []
        summary = self.results["summary"]

        if summary["success_rate"] >= 90:
            recommendations.append(
                "üéâ Version stable excellente ! Pr√™te pour la production."
            )
        elif summary["success_rate"] >= 80:
            recommendations.append(
                "‚úÖ Version stable correcte. Quelques am√©liorations mineures"
                + "recommand√©es.",
            )
        elif summary["success_rate"] >= 60:
            recommendations.append(
                "‚ö†Ô∏è Version stable avec des probl√®mes. Corrections"
                + "n√©cessaires avant production.",
            )
        else:
            recommendations.append(
                "‚ùå Version instable. Corrections majeures requises."
            )

        # Recommandations sp√©cifiques bas√©es sur les tests
        for test_name, result in self.results["tests"].items():
            if not result["success"]:
                recommendations.append(f"üîß Corriger les probl√®mes dans {test_name}")

        if summary["total_duration"] > 600:  # Plus de 10 minutes
            recommendations.append("‚ö° Optimiser les temps d'ex√©cution des tests")

        return recommendations

    def generate_report(self) -> str:
        """G√©n√®re un rapport complet"""
        summary = self.results["summary"]

        report = f"""
üéÆ RAPPORT DE TESTS VERSION STABLE - ARKALIA QUEST
==================================================

üìä R√âSUM√â GLOBAL
----------------
‚úÖ Tests r√©ussis: {summary["successful_tests"]}/{summary["total_tests"]}
‚ùå Tests √©chou√©s: {summary["failed_tests"]}/{summary["total_tests"]}
üìà Taux de r√©ussite: {summary["success_rate"]:.1f}%
‚è±Ô∏è Dur√©e totale: {summary["total_duration"]:.2f} secondes
üïê Timestamp: {summary["timestamp"]}

üîç D√âTAIL PAR TEST
------------------
"""

        for test_name, result in self.results["tests"].items():
            status = "‚úÖ R√âUSSI" if result["success"] else "‚ùå √âCHOU√â"
            report += f"{status} - {test_name}\n"
            report += f"   Dur√©e: {result['duration']:.2f}s\n"
            report += f"   Description: {result['description']}\n"

            if result["error"]:
                report += f"   Erreur: {result['error'][:100]}...\n"

            report += "\n"

        # Recommandations
        if self.results["recommendations"]:
            report += "üéØ RECOMMANDATIONS\n"
            report += "------------------\n"
            for rec in self.results["recommendations"]:
                report += f"{rec}\n"
            report += "\n"

        # Conclusion
        report += "üèÅ CONCLUSION\n"
        report += "-------------\n"

        if summary["success_rate"] >= 90:
            report += "üåü VERSION STABLE VALID√âE ! Pr√™te pour la production.\n"
        elif summary["success_rate"] >= 80:
            report += (
                "‚úÖ VERSION STABLE ACCEPTABLE. Quelques am√©liorations recommand√©es.\n"
            )
        elif summary["success_rate"] >= 60:
            report += "‚ö†Ô∏è VERSION STABLE AVEC R√âSERVES. Corrections n√©cessaires.\n"
        else:
            report += "‚ùå VERSION NON STABLE. Corrections majeures requises.\n"

        return report

    def run_all_tests(self):
        """Ex√©cute tous les tests"""
        self.log("üöÄ D√âMARRAGE DES TESTS VERSION STABLE ARKALIA QUEST")
        self.log("=" * 60)

        # V√©rifier le serveur
        if not self.check_server_status():
            self.log("‚ùå Serveur non disponible, arr√™t des tests", "ERROR")
            return False

        # Ex√©cuter tous les tests
        for module in self.test_modules:
            result = self.run_test_module(module)
            self.results["tests"][module["name"]] = result

        # G√©n√©rer le r√©sum√©
        self.results["summary"] = self.generate_summary()

        # G√©n√©rer les recommandations
        self.results["recommendations"] = self.generate_recommendations()

        # Afficher le rapport
        report = self.generate_report()
        print(report)

        # Sauvegarder les r√©sultats
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = f"stable_version_test_report_{timestamp}.json"

        with open(report_file, encoding="utf-8", mode="w") as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)

        self.log(f"üìÑ Rapport sauvegard√©: {report_file}")

        # Retourner le succ√®s global
        return self.results["summary"]["success_rate"] >= 80


def main():
    """Fonction principale"""
    print("üéÆ ARKALIA QUEST - LANCEUR DE TESTS VERSION STABLE")
    print("=" * 60)

    runner = StableVersionTestRunner()
    success = runner.run_all_tests()

    if success:
        print("\nüéâ VERSION STABLE VALID√âE !")
        return 0
    print("\n‚ö†Ô∏è VERSION N√âCESSITE DES CORRECTIONS")
    return 1


if __name__ == "__main__":
    exit(main())
