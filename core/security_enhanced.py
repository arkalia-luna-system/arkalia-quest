#!/usr/bin/env python3
"""
Syst√®me de s√©curit√© am√©lior√© pour Arkalia Quest
"""

import hashlib
import re
import secrets
import time
from collections import defaultdict, deque
from datetime import datetime
from typing import Dict, Optional, Tuple


class SecurityEnhanced:
    """Syst√®me de s√©curit√© avanc√© avec rate limiting et validation"""

    def __init__(self):
        """Initialise le syst√®me de s√©curit√©"""
        self.rate_limits = defaultdict(lambda: deque())
        self.blocked_ips = {}
        self.suspicious_activities = defaultdict(list)
        self.login_attempts = defaultdict(list)

        # Configuration de s√©curit√©
        self.config = {
            "max_requests_per_minute": 60,
            "max_requests_per_hour": 1000,
            "max_login_attempts": 5,
            "block_duration_minutes": 15,
            "suspicious_threshold": 10,
            "max_session_duration_hours": 24,
        }

        # Patterns de validation
        self.validation_patterns = {
            "username": re.compile(r"^[a-zA-Z0-9_-]{3,20}$"),
            "email": re.compile(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"),
            "password": re.compile(
                r"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$"
            ),
            "game_id": re.compile(r"^[a-zA-Z0-9_-]+$"),
            "command": re.compile(r"^[a-zA-Z0-9_\s-]+$"),
        }

    def validate_input(self, input_type: str, value: str) -> Tuple[bool, str]:
        """
        Valide une entr√©e utilisateur

        Args:
            input_type: Type d'entr√©e (username, email, password, etc.)
            value: Valeur √† valider

        Returns:
            Tuple (is_valid, error_message)
        """
        if not value or not isinstance(value, str):
            return False, "Valeur invalide"

        # V√©rifier la longueur
        if len(value) > 1000:  # Limite de s√©curit√©
            return False, "Valeur trop longue"

        # V√©rifier les caract√®res dangereux
        dangerous_chars = ["<", ">", '"', "'", "&", ";", "(", ")", "|", "`", "$"]
        if any(char in value for char in dangerous_chars):
            return False, "Caract√®res non autoris√©s d√©tect√©s"

        # Validation sp√©cifique par type
        if input_type in self.validation_patterns:
            pattern = self.validation_patterns[input_type]
            if not pattern.match(value):
                return False, f"Format {input_type} invalide"

        return True, ""

    def check_rate_limit(self, ip_address: str) -> Tuple[bool, str]:
        """
        V√©rifie si une IP respecte les limites de taux

        Args:
            ip_address: Adresse IP √† v√©rifier

        Returns:
            Tuple (is_allowed, message)
        """
        current_time = time.time()

        # Nettoyer les anciennes requ√™tes
        while (
            self.rate_limits[ip_address]
            and current_time - self.rate_limits[ip_address][0] > 60
        ):
            self.rate_limits[ip_address].popleft()

        # V√©rifier la limite par minute
        if len(self.rate_limits[ip_address]) >= self.config["max_requests_per_minute"]:
            self._log_suspicious_activity(ip_address, "rate_limit_exceeded")
            return False, "Trop de requ√™tes. Veuillez patienter."

        # Ajouter la requ√™te actuelle
        self.rate_limits[ip_address].append(current_time)

        return True, ""

    def check_login_attempts(self, ip_address: str, username: str) -> Tuple[bool, str]:
        """
        V√©rifie les tentatives de connexion

        Args:
            ip_address: Adresse IP
            username: Nom d'utilisateur

        Returns:
            Tuple (is_allowed, message)
        """
        current_time = time.time()
        key = f"{ip_address}:{username}"

        # Nettoyer les anciennes tentatives
        self.login_attempts[key] = [
            attempt
            for attempt in self.login_attempts[key]
            if current_time - attempt < 3600  # 1 heure
        ]

        # V√©rifier la limite
        if len(self.login_attempts[key]) >= self.config["max_login_attempts"]:
            self._log_suspicious_activity(ip_address, "login_brute_force", username)
            return False, "Trop de tentatives de connexion. Veuillez patienter."

        return True, ""

    def record_login_attempt(self, ip_address: str, username: str, success: bool):
        """
        Enregistre une tentative de connexion

        Args:
            ip_address: Adresse IP
            username: Nom d'utilisateur
            success: Succ√®s de la connexion
        """
        current_time = time.time()
        key = f"{ip_address}:{username}"

        if not success:
            self.login_attempts[key].append(current_time)
        else:
            # R√©initialiser les tentatives en cas de succ√®s
            self.login_attempts[key] = []

    def is_ip_blocked(self, ip_address: str) -> bool:
        """
        V√©rifie si une IP est bloqu√©e

        Args:
            ip_address: Adresse IP √† v√©rifier

        Returns:
            True si l'IP est bloqu√©e
        """
        if ip_address in self.blocked_ips:
            block_until = self.blocked_ips[ip_address]
            if time.time() < block_until:
                return True
            else:
                # D√©bloquer l'IP
                del self.blocked_ips[ip_address]

        return False

    def block_ip(self, ip_address: str, duration_minutes: Optional[int] = None):
        """
        Bloque une adresse IP

        Args:
            ip_address: Adresse IP √† bloquer
            duration_minutes: Dur√©e du blocage en minutes
        """
        if duration_minutes is None:
            duration_minutes = self.config["block_duration_minutes"]

        block_until = time.time() + (duration_minutes * 60)
        self.blocked_ips[ip_address] = block_until

        self._log_security_event(
            "ip_blocked",
            {
                "ip": ip_address,
                "duration_minutes": duration_minutes,
                "blocked_until": datetime.fromtimestamp(block_until).isoformat(),
            },
        )

    def _log_suspicious_activity(
        self, ip_address: str, activity_type: str, details: str = ""
    ):
        """
        Enregistre une activit√© suspecte

        Args:
            ip_address: Adresse IP
            activity_type: Type d'activit√©
            details: D√©tails suppl√©mentaires
        """
        current_time = time.time()

        self.suspicious_activities[ip_address].append(
            {"timestamp": current_time, "type": activity_type, "details": details}
        )

        # Nettoyer les anciennes activit√©s
        self.suspicious_activities[ip_address] = [
            activity
            for activity in self.suspicious_activities[ip_address]
            if current_time - activity["timestamp"] < 3600  # 1 heure
        ]

        # V√©rifier si l'IP doit √™tre bloqu√©e
        if (
            len(self.suspicious_activities[ip_address])
            >= self.config["suspicious_threshold"]
        ):
            self.block_ip(ip_address)

        self._log_security_event(
            "suspicious_activity",
            {
                "ip": ip_address,
                "activity_type": activity_type,
                "details": details,
                "total_activities": len(self.suspicious_activities[ip_address]),
            },
        )

    def _log_security_event(self, event_type: str, data: Dict):
        """
        Enregistre un √©v√©nement de s√©curit√©

        Args:
            event_type: Type d'√©v√©nement
            data: Donn√©es de l'√©v√©nement
        """
        # Log l'√©v√©nement de s√©curit√©
        print(f"üîí SECURITY EVENT: {event_type} - {data}")

    def generate_secure_token(self, length: int = 32) -> str:
        """
        G√©n√®re un token s√©curis√©

        Args:
            length: Longueur du token

        Returns:
            Token s√©curis√©
        """
        return secrets.token_urlsafe(length)

    def hash_password(self, password: str) -> str:
        """
        Hache un mot de passe de mani√®re s√©curis√©e

        Args:
            password: Mot de passe en clair

        Returns:
            Mot de passe hach√©
        """
        salt = secrets.token_hex(16)
        password_hash = hashlib.pbkdf2_hmac(
            "sha256", password.encode(), salt.encode(), 100000
        )
        return f"{salt}:{password_hash.hex()}"

    def verify_password(self, password: str, hashed_password: str) -> bool:
        """
        V√©rifie un mot de passe

        Args:
            password: Mot de passe en clair
            hashed_password: Mot de passe hach√©

        Returns:
            True si le mot de passe est correct
        """
        try:
            salt, stored_hash = hashed_password.split(":")
            password_hash = hashlib.pbkdf2_hmac(
                "sha256", password.encode(), salt.encode(), 100000
            )
            return password_hash.hex() == stored_hash
        except (ValueError, AttributeError):
            return False

    def get_security_stats(self) -> Dict:
        """
        Retourne les statistiques de s√©curit√©

        Returns:
            Dictionnaire avec les statistiques
        """
        current_time = time.time()

        # Compter les IPs actives
        active_ips = len(
            [
                ip
                for ip, requests in self.rate_limits.items()
                if requests and current_time - requests[-1] < 3600
            ]
        )

        # Compter les IPs bloqu√©es
        blocked_ips = len(
            [
                ip
                for ip, block_until in self.blocked_ips.items()
                if current_time < block_until
            ]
        )

        # Compter les activit√©s suspectes
        suspicious_ips = len(
            [
                ip
                for ip, activities in self.suspicious_activities.items()
                if activities and current_time - activities[-1]["timestamp"] < 3600
            ]
        )

        return {
            "active_ips": active_ips,
            "blocked_ips": blocked_ips,
            "suspicious_ips": suspicious_ips,
            "total_rate_limits": len(self.rate_limits),
            "total_login_attempts": len(self.login_attempts),
            "config": self.config,
        }


# Instance globale du syst√®me de s√©curit√©
security_enhanced = SecurityEnhanced()
