#!/usr/bin/env python3
"""
Test automatis√© pour validation utilisateur d'Arkalia Quest
Compl√®te les tests manuels avec des v√©rifications automatiques
"""

import json
import os
import sys
from datetime import datetime

# Ajouter le r√©pertoire parent au path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


class TestUtilisateurAutomated:
    """Classe pour les tests automatis√©s de validation utilisateur"""

    def __init__(self):
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "tests": {},
            "summary": {},
        }

    def test_interface_responsive(self):
        """Test de la responsivit√© de l'interface"""
        print("üì± Test de responsivit√©...")

        # V√©rifier que les fichiers CSS responsive existent
        css_files = ["static/css/responsive.css", "static/css/arkalia-luna-vision.css"]

        responsive_ok = True
        for css_file in css_files:
            if not os.path.exists(css_file):
                print(f"‚ùå {css_file} manquant")
                responsive_ok = False
            else:
                print(f"‚úÖ {css_file} pr√©sent")

        self.results["tests"]["responsive"] = {
            "status": "pass" if responsive_ok else "fail",
            "details": (
                "Fichiers CSS responsive pr√©sents"
                if responsive_ok
                else "Fichiers CSS manquants"
            ),
        }
        return responsive_ok

    def test_accessibility(self):
        """Test des fonctionnalit√©s d'accessibilit√©"""
        print("‚ôø Test d'accessibilit√©...")

        # V√©rifier les fichiers d'accessibilit√©
        accessibility_files = [
            "static/css/accessibility.css",
            "static/js/accessibility.js",
        ]

        accessibility_ok = True
        for file in accessibility_files:
            if not os.path.exists(file):
                print(f"‚ùå {file} manquant")
                accessibility_ok = False
            else:
                print(f"‚úÖ {file} pr√©sent")

        # V√©rifier le contenu du fichier CSS d'accessibilit√©
        if os.path.exists("static/css/accessibility.css"):
            with open("static/css/accessibility.css", "r") as f:
                content = f.read()
                if "contrast" in content.lower() and "focus" in content.lower():
                    print("‚úÖ Styles d'accessibilit√© d√©tect√©s")
                else:
                    print("‚ö†Ô∏è Styles d'accessibilit√© limit√©s")
                    accessibility_ok = False

        self.results["tests"]["accessibility"] = {
            "status": "pass" if accessibility_ok else "fail",
            "details": (
                "Fonctionnalit√©s d'accessibilit√© pr√©sentes"
                if accessibility_ok
                else "Fonctionnalit√©s d'accessibilit√© manquantes"
            ),
        }
        return accessibility_ok

    def test_performance_files(self):
        """Test de la performance des fichiers"""
        print("‚ö° Test de performance...")

        # V√©rifier la taille des fichiers principaux
        files_to_check = [
            "static/js/mini-games-interface.js",
            "static/css/arkalia-luna-vision.css",
            "static/js/terminal.js",
        ]

        performance_ok = True
        for file_path in files_to_check:
            if os.path.exists(file_path):
                size = os.path.getsize(file_path)
                size_kb = size / 1024
                print(f"üìä {file_path}: {size_kb:.1f} KB")

                # V√©rifier que les fichiers ne sont pas trop lourds
                if size_kb > 100:  # Plus de 100KB
                    print(f"‚ö†Ô∏è {file_path} est assez lourd ({size_kb:.1f} KB)")
                else:
                    print(f"‚úÖ {file_path} taille acceptable")
            else:
                print(f"‚ùå {file_path} manquant")
                performance_ok = False

        self.results["tests"]["performance"] = {
            "status": "pass" if performance_ok else "fail",
            "details": (
                "Fichiers de taille acceptable"
                if performance_ok
                else "Probl√®mes de taille de fichiers"
            ),
        }
        return performance_ok

    def test_content_quality(self):
        """Test de la qualit√© du contenu"""
        print("üìö Test de qualit√© du contenu...")

        # V√©rifier les missions
        missions_dir = "data/missions"
        missions_ok = True

        if os.path.exists(missions_dir):
            mission_files = [f for f in os.listdir(missions_dir) if f.endswith(".json")]
            print(f"üìã {len(mission_files)} missions trouv√©es")

            for mission_file in mission_files:
                try:
                    with open(
                        os.path.join(missions_dir, mission_file), "r", encoding="utf-8"
                    ) as f:
                        mission = json.load(f)

                    # V√©rifier la structure de la mission
                    required_fields = [
                        "id",
                        "title",
                        "description",
                        "difficulty",
                        "steps",
                    ]
                    for field in required_fields:
                        if field not in mission:
                            print(f"‚ùå {mission_file}: champ '{field}' manquant")
                            missions_ok = False

                    if missions_ok:
                        print(f"‚úÖ {mission_file}: structure correcte")

                except Exception as e:
                    print(f"‚ùå Erreur lecture {mission_file}: {e}")
                    missions_ok = False
        else:
            print("‚ùå Dossier missions manquant")
            missions_ok = False

        # V√©rifier les badges
        badges_ok = True
        if os.path.exists("data/badges_secrets.json"):
            try:
                with open("data/badges_secrets.json", "r", encoding="utf-8") as f:
                    badges = json.load(f)

                if "badges_secrets" in badges:
                    badge_count = len(badges["badges_secrets"])
                    print(f"üèÜ {badge_count} badges trouv√©s")

                    if badge_count >= 10:
                        print("‚úÖ Nombre de badges suffisant")
                    else:
                        print("‚ö†Ô∏è Peu de badges disponibles")
                        badges_ok = False
                else:
                    print("‚ùå Structure badges incorrecte")
                    badges_ok = False

            except Exception as e:
                print(f"‚ùå Erreur lecture badges: {e}")
                badges_ok = False
        else:
            print("‚ùå Fichier badges manquant")
            badges_ok = False

        content_ok = missions_ok and badges_ok
        self.results["tests"]["content_quality"] = {
            "status": "pass" if content_ok else "fail",
            "details": "Contenu de qualit√©" if content_ok else "Probl√®mes de contenu",
        }
        return content_ok

    def test_educational_value(self):
        """Test de la valeur √©ducative"""
        print("üéì Test de valeur √©ducative...")

        try:
            from core.educational_games_engine import EducationalGamesEngine

            ege = EducationalGamesEngine()
            games = ege.get_available_games(1)

            print(f"üéÆ {len(games)} mini-jeux disponibles")

            # Analyser les types de jeux
            game_types = {}
            for game in games:
                game_type = game.get("type", "unknown")
                game_types[game_type] = game_types.get(game_type, 0) + 1

            print("üìä Types de jeux:")
            for game_type, count in game_types.items():
                print(f"  - {game_type}: {count} jeux")

            # V√©rifier la diversit√©
            if len(game_types) >= 3:
                print("‚úÖ Diversit√© des types de jeux")
                educational_ok = True
            else:
                print("‚ö†Ô∏è Peu de diversit√© dans les types de jeux")
                educational_ok = False

            # V√©rifier les points
            total_points = sum(game.get("points", 0) for game in games)
            print(f"üéØ Total points disponibles: {total_points}")

            if total_points >= 500:
                print("‚úÖ Syst√®me de points √©quilibr√©")
            else:
                print("‚ö†Ô∏è Peu de points disponibles")
                educational_ok = False

        except Exception as e:
            print(f"‚ùå Erreur test √©ducatif: {e}")
            educational_ok = False

        self.results["tests"]["educational_value"] = {
            "status": "pass" if educational_ok else "fail",
            "details": (
                "Valeur √©ducative √©lev√©e"
                if educational_ok
                else "Valeur √©ducative limit√©e"
            ),
        }
        return educational_ok

    def run_all_tests(self):
        """Ex√©cute tous les tests automatis√©s"""
        print("üöÄ TESTS AUTOMATIS√âS DE VALIDATION UTILISATEUR")
        print("=" * 60)

        tests = [
            ("Interface Responsive", self.test_interface_responsive),
            ("Accessibilit√©", self.test_accessibility),
            ("Performance", self.test_performance_files),
            ("Qualit√© du Contenu", self.test_content_quality),
            ("Valeur √âducative", self.test_educational_value),
        ]

        results = []
        for test_name, test_func in tests:
            print(f"\nüîç {test_name}...")
            try:
                result = test_func()
                results.append(result)
                print(
                    f"{'‚úÖ' if result else '‚ùå'} {test_name}: {'PASS' if result else 'FAIL'}"
                )
            except Exception as e:
                print(f"üí• Erreur dans {test_name}: {e}")
                results.append(False)

        # R√©sum√©
        passed = sum(results)
        total = len(results)

        print("\n" + "=" * 60)
        print("üìä R√âSULTATS DES TESTS AUTOMATIS√âS:")
        print(f"‚úÖ Tests r√©ussis: {passed}/{total}")
        print(f"‚ùå Tests √©chou√©s: {total - passed}/{total}")

        self.results["summary"] = {
            "total_tests": total,
            "passed_tests": passed,
            "failed_tests": total - passed,
            "success_rate": (passed / total) * 100 if total > 0 else 0,
        }

        if passed == total:
            print("\nüéâ TOUS LES TESTS AUTOMATIS√âS SONT PASS√âS !")
            print("‚úÖ Le jeu est pr√™t pour les tests utilisateur manuels")
        else:
            print(f"\n‚ö†Ô∏è {total - passed} test(s) ont √©chou√©")
            print("üîß Des corrections sont n√©cessaires avant les tests utilisateur")

        return passed == total

    def save_report(self, filename="test_utilisateur_automated_report.json"):
        """Sauvegarde le rapport de test"""
        report_path = os.path.join("tests", "reports", filename)
        os.makedirs(os.path.dirname(report_path), exist_ok=True)

        with open(report_path, "w", encoding="utf-8") as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)

        print(f"\nüìÑ Rapport sauvegard√©: {report_path}")


def main():
    """Fonction principale"""
    tester = TestUtilisateurAutomated()
    success = tester.run_all_tests()
    tester.save_report()

    return 0 if success else 1


if __name__ == "__main__":
    exit_code = main()
    sys.exit(exit_code)
