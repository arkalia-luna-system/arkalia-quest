#!/usr/bin/env python3
"""
üß™ Test Complet du Syst√®me Immersif - Arkalia Quest
Test int√©gr√© du syst√®me d'√©motions LUNA et des effets visuels
"""

import json
import random
import time
from datetime import datetime
from typing import Any, Dict

import requests


class ImmersiveSystemTester:
    """Testeur complet du syst√®me immersif"""

    def __init__(self, base_url: str = "http://localhost:5001"):
        self.base_url = base_url
        self.session = requests.Session()
        self.test_results = []
        self.luna_emotions_seen = set()
        self.effects_triggered = set()

        # Donn√©es de test
        self.test_commands = [
            "aide",
            "profil",
            "hack_system",
            "kill_virus",
            "find_shadow",
            "luna_contact",
            "luna_engine",
            "luna_analyze",
            "badges",
            "monde",
            "commande_inexistante_test"
        ]

    def run_complete_test(self) -> Dict[str, Any]:
        """Lance le test complet du syst√®me immersif"""
        print("üåü TEST COMPLET DU SYST√àME IMMERSIF ARKALIA QUEST")
        print("=" * 60)

        start_time = time.time()

        # Tests du syst√®me d'√©motions LUNA
        print("\nüåô TEST 1: SYST√àME D'√âMOTIONS LUNA")
        luna_results = self.test_luna_emotions()

        # Tests des effets visuels
        print("\nüé® TEST 2: EFFETS VISUELS IMMERSIFS")
        visual_results = self.test_visual_effects()

        # Tests d'int√©gration
        print("\nüîó TEST 3: INT√âGRATION COMPL√àTE")
        integration_results = self.test_integration()

        # Tests de performance
        print("\n‚ö° TEST 4: PERFORMANCE ET STABILIT√â")
        performance_results = self.test_performance()

        end_time = time.time()
        total_duration = end_time - start_time

        # Compilation des r√©sultats
        results = {
            "timestamp": datetime.now().isoformat(),
            "duration": total_duration,
            "luna_emotions": luna_results,
            "visual_effects": visual_results,
            "integration": integration_results,
            "performance": performance_results,
            "summary": self.generate_summary(luna_results, visual_results, integration_results, performance_results)
        }

        # Sauvegarder les r√©sultats
        self.save_results(results)

        # Afficher le r√©sum√©
        self.display_summary(results)

        return results

    def test_luna_emotions(self) -> Dict[str, Any]:
        """Test du syst√®me d'√©motions LUNA"""
        print("  üß™ Test des √©motions LUNA...")

        emotions_test = {
            "total_commands": 0,
            "emotions_detected": 0,
            "emotion_types": set(),
            "intensity_range": {"min": 1.0, "max": 0.0},
            "response_times": [],
            "errors": []
        }

        for command in self.test_commands:
            try:
                start_time = time.time()

                response = self.session.post(
                    f"{self.base_url}/commande",
                    json={"commande": command},
                    timeout=10
                )

                response_time = time.time() - start_time
                emotions_test["response_times"].append(response_time)

                if response.status_code == 200:
                    data = response.json()
                    # Adapter pour parser la cl√© 'reponse'
                    if "reponse" in data:
                        data = data["reponse"]
                    emotions_test["total_commands"] += 1

                    # V√©rifier la pr√©sence d'√©motions LUNA
                    if "luna_emotion" in data:
                        emotions_test["emotions_detected"] += 1
                        emotions_test["emotion_types"].add(data["luna_emotion"])
                        self.luna_emotions_seen.add(data["luna_emotion"])

                        # V√©rifier l'intensit√©
                        intensity = data.get("luna_intensity", 0.5)
                        emotions_test["intensity_range"]["min"] = min(emotions_test["intensity_range"]["min"], intensity)
                        emotions_test["intensity_range"]["max"] = max(emotions_test["intensity_range"]["max"], intensity)

                        # V√©rifier la coh√©rence
                        self.validate_emotion_data(data)

                        print(f"    ‚úÖ {command}: {data['luna_emotion']} (intensit√©: {intensity:.2f})")
                    else:
                        print(f"    ‚ö†Ô∏è {command}: Pas d'√©motion LUNA d√©tect√©e")
                        emotions_test["errors"].append(f"Pas d'√©motion pour {command}")
                else:
                    print(f"    ‚ùå {command}: Erreur HTTP {response.status_code}")
                    emotions_test["errors"].append(f"HTTP {response.status_code} pour {command}")

            except Exception as e:
                print(f"    üí• {command}: Erreur - {str(e)}")
                emotions_test["errors"].append(f"Exception pour {command}: {str(e)}")

        # Calculer les statistiques
        emotions_test["emotion_types"] = list(emotions_test["emotion_types"])
        emotions_test["avg_response_time"] = sum(emotions_test["response_times"]) / len(emotions_test["response_times"]) if emotions_test["response_times"] else 0
        emotions_test["success_rate"] = (emotions_test["emotions_detected"] / emotions_test["total_commands"]) * 100 if emotions_test["total_commands"] > 0 else 0

        return emotions_test

    def test_visual_effects(self) -> Dict[str, Any]:
        """Test des effets visuels"""
        print("  üé® Test des effets visuels...")

        effects_test = {
            "effects_detected": 0,
            "effect_types": set(),
            "colors_detected": set(),
            "sounds_detected": set(),
            "errors": []
        }

        # Tester avec des commandes qui d√©clenchent des effets
        effect_commands = ["hack_system", "kill_virus", "luna_contact", "luna_engine"]

        for command in effect_commands:
            try:
                response = self.session.post(
                    f"{self.base_url}/commande",
                    json={"commande": command},
                    timeout=10
                )

                if response.status_code == 200:
                    data = response.json()
                    # Adapter pour parser la cl√© 'reponse'
                    if "reponse" in data:
                        data = data["reponse"]

                    # V√©rifier les effets
                    if "luna_effect" in data:
                        effects_test["effects_detected"] += 1
                        effects_test["effect_types"].add(data["luna_effect"])
                        self.effects_triggered.add(data["luna_effect"])

                    if "luna_color" in data:
                        effects_test["colors_detected"].add(data["luna_color"])

                    if "luna_sound" in data:
                        effects_test["sounds_detected"].add(data["luna_sound"])

                    print(f"    ‚úÖ {command}: Effet {data.get('luna_effect', 'N/A')} - Couleur {data.get('luna_color', 'N/A')}")
                else:
                    print(f"    ‚ùå {command}: Erreur HTTP {response.status_code}")
                    effects_test["errors"].append(f"HTTP {response.status_code} pour {command}")

            except Exception as e:
                print(f"    üí• {command}: Erreur - {str(e)}")
                effects_test["errors"].append(f"Exception pour {command}: {str(e)}")

        # Convertir les sets en listes
        effects_test["effect_types"] = list(effects_test["effect_types"])
        effects_test["colors_detected"] = list(effects_test["colors_detected"])
        effects_test["sounds_detected"] = list(effects_test["sounds_detected"])

        return effects_test

    def test_integration(self) -> Dict[str, Any]:
        """Test d'int√©gration compl√®te"""
        print("  üîó Test d'int√©gration...")

        integration_test = {
            "integration_checks": 0,
            "integration_success": 0,
            "coherence_checks": 0,
            "coherence_success": 0,
            "errors": []
        }

        # Test de coh√©rence √©motion-effet
        for command in self.test_commands[:5]:  # Test avec 5 commandes
            try:
                response = self.session.post(
                    f"{self.base_url}/commande",
                    json={"commande": command},
                    timeout=10
                )

                if response.status_code == 200:
                    data = response.json()
                    # Adapter pour parser la cl√© 'reponse'
                    if "reponse" in data:
                        data = data["reponse"]
                    integration_test["integration_checks"] += 1

                    # V√©rifier la coh√©rence
                    if self.check_emotion_effect_coherence(data):
                        integration_test["integration_success"] += 1
                        print(f"    ‚úÖ {command}: Coh√©rence √©motion-effet OK")
                    else:
                        print(f"    ‚ö†Ô∏è {command}: Incoh√©rence √©motion-effet d√©tect√©e")
                        integration_test["errors"].append(f"Incoh√©rence pour {command}")

                    # V√©rifier la structure des donn√©es
                    if self.validate_response_structure(data):
                        integration_test["coherence_success"] += 1
                    else:
                        integration_test["errors"].append(f"Structure invalide pour {command}")

                    integration_test["coherence_checks"] += 1

            except Exception as e:
                print(f"    üí• {command}: Erreur - {str(e)}")
                integration_test["errors"].append(f"Exception pour {command}: {str(e)}")

        # Calculer les taux de r√©ussite
        integration_test["integration_rate"] = (integration_test["integration_success"] / integration_test["integration_checks"]) * 100 if integration_test["integration_checks"] > 0 else 0
        integration_test["coherence_rate"] = (integration_test["coherence_success"] / integration_test["coherence_checks"]) * 100 if integration_test["coherence_checks"] > 0 else 0

        return integration_test

    def test_performance(self) -> Dict[str, Any]:
        """Test de performance"""
        print("  ‚ö° Test de performance...")

        performance_test = {
            "total_requests": 0,
            "successful_requests": 0,
            "response_times": [],
            "errors": [],
            "stress_test_results": {}
        }

        # Test de charge simple
        print("    üöÄ Test de charge (10 requ√™tes simultan√©es)...")

        import queue
        import threading

        results_queue = queue.Queue()

        def make_request(command, request_id):
            try:
                start_time = time.time()
                response = self.session.post(
                    f"{self.base_url}/commande",
                    json={"commande": command},
                    timeout=5
                )
                response_time = time.time() - start_time

                # Adapter pour parser la cl√© 'reponse'
                data = None
                if response.status_code == 200:
                    try:
                        data = response.json()
                        if "reponse" in data:
                            data = data["reponse"]
                    except Exception:
                        pass

                results_queue.put({
                    "request_id": request_id,
                    "success": response.status_code == 200,
                    "response_time": response_time,
                    "status_code": response.status_code,
                    "data": data
                })
            except Exception as e:
                results_queue.put({
                    "request_id": request_id,
                    "success": False,
                    "response_time": 0,
                    "error": str(e)
                })

        # Lancer 10 requ√™tes simultan√©es
        threads = []
        for i in range(10):
            command = random.choice(self.test_commands)
            thread = threading.Thread(target=make_request, args=(command, i))
            threads.append(thread)
            thread.start()

        # Attendre la fin de tous les threads
        for thread in threads:
            thread.join()

        # Collecter les r√©sultats
        while not results_queue.empty():
            result = results_queue.get()
            performance_test["total_requests"] += 1

            if result["success"]:
                performance_test["successful_requests"] += 1
                performance_test["response_times"].append(result["response_time"])
            else:
                performance_test["errors"].append(f"Requ√™te {result['request_id']}: √âchec")

        # Calculer les statistiques
        if performance_test["response_times"]:
            performance_test["avg_response_time"] = sum(performance_test["response_times"]) / len(performance_test["response_times"])
            performance_test["min_response_time"] = min(performance_test["response_times"])
            performance_test["max_response_time"] = max(performance_test["response_times"])
        else:
            performance_test["avg_response_time"] = 0
            performance_test["min_response_time"] = 0
            performance_test["max_response_time"] = 0

        performance_test["success_rate"] = (performance_test["successful_requests"] / performance_test["total_requests"]) * 100 if performance_test["total_requests"] > 0 else 0

        print(f"    üìä Performance: {performance_test['success_rate']:.1f}% succ√®s, {performance_test['avg_response_time']:.3f}s moyenne")

        return performance_test

    def validate_emotion_data(self, data: Dict[str, Any]) -> bool:
        """Valide les donn√©es d'√©motion"""
        required_fields = ["luna_emotion", "luna_intensity", "luna_color", "luna_effect", "luna_sound"]

        for field in required_fields:
            if field not in data:
                return False

        # V√©rifier les types
        if not isinstance(data["luna_emotion"], str):
            return False
        if not isinstance(data["luna_intensity"], (int, float)):
            return False
        if not isinstance(data["luna_color"], str):
            return False
        if not isinstance(data["luna_effect"], str):
            return False
        if not isinstance(data["luna_sound"], str):
            return False

        # V√©rifier les bornes
        if not (0.0 <= data["luna_intensity"] <= 1.0):
            return False

        return True

    def check_emotion_effect_coherence(self, data: Dict[str, Any]) -> bool:
        """V√©rifie la coh√©rence √©motion-effet"""
        if "luna_emotion" not in data or "luna_effect" not in data:
            return False

        # Mapping √©motion-effet attendu
        expected_mapping = {
            "excited": "pulse_green",
            "worried": "shake_orange",
            "proud": "sparkle_magenta",
            "mysterious": "fade_cyan",
            "determined": "glow_red",
            "playful": "bounce_yellow",
            "focused": "zoom_blue",
            "surprised": "flash_pink",
            "calm": "float_lightblue",
            "energetic": "vibrate_green"
        }

        emotion = data["luna_emotion"]
        effect = data["luna_effect"]

        return expected_mapping.get(emotion) == effect

    def validate_response_structure(self, data: Dict[str, Any]) -> bool:
        """Valide la structure de la r√©ponse"""
        required_fields = ["r√©ussite", "message"]

        for field in required_fields:
            if field not in data:
                return False

        return True

    def generate_summary(self, luna_results: Dict, visual_results: Dict, integration_results: Dict, performance_results: Dict) -> Dict[str, Any]:
        """G√©n√®re un r√©sum√© des tests"""
        total_tests = (
            luna_results.get("total_commands", 0) +
            len(visual_results.get("effect_types", [])) +
            integration_results.get("integration_checks", 0) +
            performance_results.get("total_requests", 0)
        )

        total_success = (
            luna_results.get("emotions_detected", 0) +
            visual_results.get("effects_detected", 0) +
            integration_results.get("integration_success", 0) +
            performance_results.get("successful_requests", 0)
        )

        overall_success_rate = (total_success / total_tests) * 100 if total_tests > 0 else 0

        return {
            "total_tests": total_tests,
            "total_success": total_success,
            "overall_success_rate": overall_success_rate,
            "emotions_detected": len(self.luna_emotions_seen),
            "effects_triggered": len(self.effects_triggered),
            "avg_response_time": performance_results.get("avg_response_time", 0),
            "status": "EXCELLENT" if overall_success_rate >= 90 else "BON" if overall_success_rate >= 75 else "MOYEN" if overall_success_rate >= 50 else "MAUVAIS"
        }

    def save_results(self, results: Dict[str, Any]):
        """Sauvegarde les r√©sultats"""
        filename = f"tests/results/immersive_system_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        # Cr√©er le dossier si n√©cessaire
        import os
        os.makedirs("tests/results", exist_ok=True)

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        print(f"\nüíæ R√©sultats sauvegard√©s dans: {filename}")

    def display_summary(self, results: Dict[str, Any]):
        """Affiche le r√©sum√© des tests"""
        summary = results["summary"]

        print("\n" + "=" * 60)
        print("üìä R√âSUM√â DU TEST IMMERSIF COMPLET")
        print("=" * 60)

        print(f"üéØ TAUX DE R√âUSSITE GLOBAL: {summary['overall_success_rate']:.1f}%")
        print(f"üìà STATUT: {summary['status']}")
        print(f"‚è±Ô∏è TEMPS TOTAL: {results['duration']:.2f} secondes")
        print(f"üåô √âMOTIONS D√âTECT√âES: {summary['emotions_detected']}")
        print(f"üé® EFFETS D√âCLENCH√âS: {summary['effects_triggered']}")
        print(f"‚ö° TEMPS DE R√âPONSE MOYEN: {summary['avg_response_time']:.3f}s")

        print("\nüìã D√âTAILS:")
        print(f"  ‚Ä¢ Tests LUNA: {results['luna_emotions']['emotions_detected']}/{results['luna_emotions']['total_commands']} √©motions d√©tect√©es")
        print(f"  ‚Ä¢ Tests visuels: {results['visual_effects']['effects_detected']} effets d√©tect√©s")
        print(f"  ‚Ä¢ Tests int√©gration: {results['integration']['integration_success']}/{results['integration']['integration_checks']} coh√©rences OK")
        print(f"  ‚Ä¢ Tests performance: {results['performance']['successful_requests']}/{results['performance']['total_requests']} requ√™tes r√©ussies")

        if summary['status'] == "EXCELLENT":
            print("\nüéâ SYST√àME IMMERSIF PARFAIT ! LUNA est pr√™te √† bluffer les ados !")
        elif summary['status'] == "BON":
            print("\nüëç SYST√àME IMMERSIF FONCTIONNEL ! Quelques ajustements mineurs recommand√©s.")
        else:
            print("\n‚ö†Ô∏è SYST√àME IMMERSIF √Ä AM√âLIORER ! Des corrections sont n√©cessaires.")


def main():
    """Fonction principale"""
    print("üåü TEST COMPLET DU SYST√àME IMMERSIF ARKALIA QUEST")
    print("=" * 60)

    # V√©rifier que le serveur est accessible
    try:
        response = requests.get("http://localhost:5001/api/status", timeout=5)
        if response.status_code != 200:
            print("‚ùå Serveur non accessible. Assurez-vous qu'Arkalia Quest est d√©marr√© sur le port 5001.")
            return False
    except:
        print("‚ùå Impossible de se connecter au serveur. Assurez-vous qu'Arkalia Quest est d√©marr√©.")
        return False

    # Lancer les tests
    tester = ImmersiveSystemTester()
    results = tester.run_complete_test()

    return results["summary"]["status"] in ["EXCELLENT", "BON"]


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)
